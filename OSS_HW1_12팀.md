# 제목: 아두이노 통합 개발 환경(Arduino IDE) 조사  

![Image](https://github.com/user-attachments/assets/8da223ef-5fe9-4cf3-88f0-244c0b77ace9)
## 팀원    
스마트생물산업기계공학과 2024008578 김창준 (Kim-changjun123)  
스마트생물산업기계공학과 2022115398 유선민 (Yoosunmin)  
스마트생물산업기계공학과 2024005163 이기원 (leekiwon123)  
스마트생물산업기계공학과 2024005258 이인현 (dldlsgus)  
스마트생물산업기계공학과 2022112962 홍석현 (hongseockhyeon)  

## 1.개요  
**Arduino IDE**는 Arduino 하드웨어 플랫폼을 프로그래밍하기 위한 공식 개발 환경입니다. Arduino는 마이크로컨트롤러 기반의 오픈소스 전자 프로젝트로, Arduino IDE는 사용자가 Arduino 보드를 쉽게 프로그래밍할 수 있도록 도와주는 소프트웨어입니다. 이 소프트웨어는 C++ 언어와 같은 프로그래밍 언어를 기반으로 하며, 직관적인 사용자 인터페이스와 다양한 라이브러리, 도구들 덕분에 초보자부터 전문가까지 쉽게 사용할 수 있습니다.

Arduino IDE는 다양한 보드와 호환되며, 코드 작성 후 컴퓨터와 Arduino 보드를 USB로 연결하여 코드를 업로드하고 테스트할 수 있습니다. 이 IDE는 특히 하드웨어와 소프트웨어의 상호작용을 배우는 데 적합하며, 다양한 센서, 액추에이터, 로봇 등과의 연동을 통해 창의적인 프로젝트를 쉽게 구현할 수 있습니다.

## 2.라이선스  
Arduino IDE는 **GNU GPL v3** 라이선스를 따릅니다. 이는 오픈소스 라이선스 중 하나로, 사용자는 소스 코드를 자유롭게 수정하고 배포할 수 있습니다. 또한, 개인 및 상업적 목적 모두에 자유롭게 사용할 수 있으며, 수정된 버전도 동일한 라이선스 하에 배포해야 합니다.

Arduino IDE의 가격은 **무료**입니다. 사용자는 소프트웨어를 공식 Arduino 웹사이트에서 다운로드하여 설치할 수 있습니다.

라이선스:
- **라이선스 유형**: GNU General Public License v3.0
- **가격**: 무료
- **배포 방식**: 오픈소스

## 3.주요기능  
### 1) **코드 작성 및 편집 기능**

아두이노(Arduino)는 전자 회로를 쉽고 직관적으로 제어할 수 있도록 설계된 오픈소스 플랫폼으로, 하드웨어와 소프트웨어 모두를 포함합니다.  

아두이노 스프트웨어는 사용자가 직접 코드를 작성하면 작성된 코드를 바탕으로 컴파일이 진행되고 작동합니다.  

아두이노는 사용자의 편의를 위해 여러가지 코드작성 과 편집에 관한 기능을 제공하여 사용자의 이용을 돕습니다.  

또한 아두이노의 소프트웨어 환경인 아두이노 IDE(통합 개발 환경)는 초보자부터 전문가까지 모두에게 친숙한 인터페이스를 제공하며, 코드 작성, 편집, 업로드를 간편하게 할 수 있도록 지원합니다.

#### 1. 자동들여쓰기 정리
아두이노는 사용자의 쉽고 편리한 사용을 위해 **자동들여쓰기**를 제공합니다.
 
void setup() {pinMode(13, OUTPUT);}      
void loop()                              
{                                        
  digitalWrite(13, HIGH);  
  
  delay(1000);  
  
  digitalWrite(13, LOW);  
  
  delay(1000);                                
}

void setup() {pinMode(13, OUTPUT);}  

void loop()                              
{                                        
     digitalWrite(13, HIGH);                      
     delay(1000);     digitalWrite(13, LOW);                           
  delay(1000);                                
}

상단코드의 경우 들여쓰기가 되어있는 코드이고 하단코드는 들여쓰기 안되어있는 코드입니다.  

한 눈에 봐도 상단이 코드의 가독성이 높고 깔끔하고 심미적으로 좋아보이고 이는 사용자의 실수를 줄이고 어떤 코드가 어떻게 작용하는지 파악에 용이하게 해줍니다.  

그럼 이 어마어마하고 놀랍고 신비로운 능력을 어떻게 사용하는지 알아봅시다.  

Windows 운영체제를 사용하는 사용자의 경우 Ctrl + T  

Mac 운영체제를 사용하는 사용자의 경우 Cmd + T  

단지 두 번의 손가락 움직임으로 가독성을 높여주고 피로를 줄여주는 놀라운 마법을 아두이노 사용자라면 누구든 사용할 수 있습니다.

#### 2. 구문 강조(Syntax Highlighting)
변수 함수 주석등은 각기 다른 역할을 수행합니다.  
하지만 이런 것들이 모두 같은 색상으로 표시된다면 무척 혼란스러울 수 있습니다.(특히 아두이노를 사용한지 얼마 안된 초보 아두이너에게)  
이럴 때 변수 함수 주석에 다른 색상이 부여된다면 아두이노 사용자는 한 눈에 어떤 것이 변수역할을 하는지 함수역할을 하는지 코드설명을 위한 주석을 역할을 하는지 손쉽게 알 수 있습니다  
이것은 아두이노에서 자동적으로 내장되어 있는 기능으로 사용자가 특별히 지정할 것은 없습니다.


#### 3.코드 자동 완성(IDE 2.x)  
아두이노 IDE 최신 버전의 경우 코드 자동 완성 기능을 제공합니다.  
우리 인간의 기억력은 한정적이고 한 번 배워서 코드를 작성했다 할지라도 시간이 지나면 잊혀지기 마련입니다. 
하지만 놀랍도록 혁신적인 기능 제공을 통해 우리는 약간의 실마리 (EX) 코드의 앞자리)를 제공하면 똑똑한 아두이노는 코드를 자동완성시켜줍니다.  

#### 4.탭 기능 사용 
복잡한 프로제트에서는 여러 개의 .ino 파일이나 .h .cpp 파일로 나누어 관리할 수 있으며 , 탭을 쉽게 전환하면서 편집이 가능합니다.  

#### 5.라이브러리 추가 및 관리  
[스케치] > [라이브러리 포함] > [라이브러리 관리...] 메뉴를 통해   
다양한 외부 라이브러리를 설치하고 사용할 수 있습니다.   
이는 센서나 통신 모듈 등을 손쉽게 제어할 수 있게 해줍니다.

#### 6.함수 정의로 이동 (Ctrl+클릭)
사용법 : 사용된 함수 이름에 마우스를 대고 클릭하면 해당 정의로 바로 이동
코드 편집을 하면서 수 많은 함수를 사용하게 됩니다. 여기서 사용한 함수의 정의를 읽어보는 것은  
함수에 대한 이해를 높여주고 이 함수가 어떤 역할을 하는지 알게 해주어 앞으로 코드를 어떻게 작성할지에 대한 인사이트를 줍니다.

#### 7. 다크 모드 지원  
우리의 아두이노는 이번에도 역시 우리를 실망시키지 않았습니다.  
다크모드는 우리의 눈 피로를 줄여주는 혁명적인 모드입니다.  
이 놀랍고 혁신적인 기능의 사용법에 대해 알아봅시다.  
1. 아두이노 ide 실행
2. 상단 메뉴에서 File > Preferences 클릭
3. Theme 항목에서 dark 선택
4. ide를 재시작 하면 다크모드 적용 완료 !!!


#### 8. 오류 밑줄 표시 및 툴팁 제공
인간은 누구나 실수를 합니다. 그렇기 때문에 인간입니다.  
심지어 아두이노 전문가 조차 예외는 없습니다.  
하지만 놀랍고 신기한 아두이노 ide는 작성자가 코드를 작성할 때 실수를 하여 오류를 발생시키면  
밑줄을 표시해주고 툴팁을 제공해 올바르게 고칠 수 있도록 도와줍니다.  
아두이노를 통해 코딩을 해 봤다면 이 기능이 얼마나 혁신적인지 공감할 수 있을 것 입니다.




### 2) **컴파일 및 업로드 기능** 

아두이노의 컴파일 과정은 소스 코드가 최종적으로 아두이노 보드에서 실행될 수 있는 기계어로 변환되는 과정입니다. 이 과정은 여러 단계를 거쳐 이루어지며, 아두이노 IDE(통합 개발 환경)를 사용하여 자동으로 처리됩니다.

#### 1. 소스 코드 작성 (스케치 작성)  
   - 사용자는 아두이노 IDE에서 C/C++ 언어로 프로그램을 작성합니다. 이를 **스케치**라고 하며, 아두이노에서 실행될 로직을 포함한 코드입니다.  

#### 2. 전처리  
   - 작성한 소스 코드가 아두이노 IDE에 의해 첫 번째 단계로 **전처리**됩니다. 전처리 단계에서는 `#include`로 포함된 라이브러리와 매크로가 처리됩니다.  
   - 아두이노에서는 `.ino` 확장자 파일을 `.cpp` 파일로 변환하여 컴파일을 준비합니다.  
   - 이 과정에서 `setup()`과 `loop()` 함수 등의 아두이노 특정 구조가 처리되고, 필요하면 `#define`, `#include`와 같은 지시문이 적용됩니다.  

#### 3. 컴파일  
   - 전처리 후, 소스 코드는 **컴파일러**로 전달됩니다.  
   - 이 단계에서는 코드의 구문 오류나 문법 오류가 확인되고, 아두이노 보드의 아키텍처에 맞는 기계어로 변환됩니다.  
   - 아두이노 보드는 AVR이나 ARM 기반이기 때문에, 컴파일러는 이들 아키텍처에 맞게 코드를 최적화합니다.  
   - 각 아두이노 보드는 자신만의 마이크로컨트롤러를 가지고 있으며, 컴파일러는 이 마이크로컨트롤러에 적합한 바이너리 파일을 생성합니다.  

#### 4. 링킹  
   - 컴파일이 완료되면, 여러 개의 오브젝트 파일이 하나로 결합되어 실행 파일을 만듭니다. 이를 **링킹**이라고 합니다.  
   - 이 단계에서 필요한 라이브러리와 함수들이 결합되고, 최종 실행 파일인 HEX 파일이 생성됩니다.  
   - HEX 파일은 아두이노 보드에 직접 업로드할 수 있는 바이너리 형태입니다.  

#### 5. 업로드  
   - 컴파일이 완료된 후, 아두이노 IDE는 생성된 HEX 파일을 보드에 **업로드**합니다.  
   - 이를 위해 아두이노 보드와 컴퓨터는 USB 연결을 통해 통신합니다.  
   - 아두이노 보드는 업로드된 코드에 맞게 내부 프로그램을 실행하게 됩니다.  

#### 6. 실행  
   - 업로드가 끝나면, 아두이노 보드는 프로그램을 실행합니다.  
   - 예를 들어, `setup()` 함수가 처음 한 번 실행되고, 그 후 `loop()` 함수가 반복적으로 실행됩니다.  

이 과정은 아두이노 보드의 종류에 따라 조금씩 다를 수 있으며, 개발자가 추가한 라이브러리나 외부 모듈에 따라 조금씩 변형될 수 있습니다.  
  
### 컴파일 단계의 개요  
컴파일 단계는 아두이노 코드가 **고수준 언어(C++)**에서 **저수준 기계어(바이너리 코드)**로 변환되는 과정입니다. 이 과정은 크게 두 가지 주요 작업을 포함합니다.  
구문 분석: 코드의 문법을 분석하여 오류를 찾고, 각 코드가 수행해야 할 작업을 이해하는 단계입니다.  
기계어 생성: 아두이노 보드에서 실행할 수 있도록, 코드가 실제 기계어로 변환되는 단계입니다.  
  
#### 1. 구문 분석  
구문 분석은 코드에서 사용된 명령어들이 올바른 문법을 따르고 있는지 점검하는 과정입니다. 이 단계에서는 코드에 문법적 오류가 없는지, 사용된 변수나 함수가 제대로 선언되었는지를 확인합니다. 주로 컴파일러가 코드의 문법을 검토하여 오류를 탐지합니다.  
주요 작업:  
• 키워드 및 식별자 확인: 코드 내에서 사용된 모든 키워드(예: int, void, for 등)와 식별자(변수, 함수 이름 등)가 올바르게 사용되었는지 확인합니다.  
• 구문 오류 검사: 예를 들어, 괄호의 짝이 맞지 않거나 세미콜론을 놓친 경우, 컴파일러는 이와 같은 오류를 찾고 이를 알려줍니다.  
• 타입 검사: 변수가 선언된 타입에 맞게 사용되고 있는지 체크합니다. 예를 들어, 정수형 변수에 문자열을 할당하려는 경우 오류가 발생합니다.  
위 코드는 구문 분석 중에 오류를 발견하고, 이를 컴파일러가 경고합니다.  
  
#### 2. 기계어 생성 (Assembly Generation)  
구문 분석이 완료되면, 코드는 이제 기계어로 변환되는 과정에 들어갑니다. 이 과정에서는 코드의 각 명령을 아두이노 보드가 이해할 수 있는 **어셈블리어**로 번역한 후, 최종적으로 **기계어**로 변환됩니다. 이 단계는 **어셈블러**라는 도구를 통해 이루어집니다.  
주요 작업:  
어셈블리어 생성: C++ 코드에서 사용된 고수준 명령어를 아두이노 보드에서 이해할 수 있는 저수준 명령어인 어셈블리어로 변환합니다.  
명령어 변환: 각 함수, 변수, 연산자는 어셈블리 명령어로 바뀌고, 아두이노 보드의 하드웨어와 연동될 수 있도록 최적화됩니다.  
  
최종 목표:  
• 기계어 코드 생성: 어셈블리어에서 더 낮은 수준의 기계어로 변환하여, 실제 아두이노 보드에서 실행할 수 있는 바이너리 파일이 만들어집니다. 이 바이너리 파일은 아두이노 보드의 플래시 메모리에 업로드될 수 있는 .hex 파일로 저장됩니다.  

#### 3. 최적화  
컴파일 단계에서의 최적화(Optimization)는 아두이노 보드에서 코드가 더 효율적으로 실행되도록 만드는 과정입니다. 이 과정은 두 가지 주요 측면에서 이루어집니다.  
1. **코드 크기 최적화**  아두이노 보드는 메모리가 제한적이기 때문에, 최적화 과정에서 불필요한 코드나 데이터를 제거하여 코드 크기를 줄이는 것이 중요합니다. 이를 통해 더 적은 메모리로 더 많은 기능을 구현할 수 있게 됩니다.  
주요 방법:  
- **불필요한 코드 제거**: 사용되지 않는 변수나 함수는 제거됩니다. 예를 들어, 사용하지 않는 함수나 라이브러리가 포함되어 있으면 컴파일러는 이를 자동으로 제거합니다.  
- **함수 인라인화 (Inlining Functions)**: 자주 호출되는 작은 함수는 호출하는 대신 **인라인(inline)**으로 처리되어, 함수 호출 오버헤드를 줄이고 메모리 사용을 절약할 수 있습니다. 예를 들어, 간단한 연산을 수행하는 함수는 함수 호출을 피하고 직접 연산을 수행하는 방식으로 최적화됩니다.  
- **라이브러리 최적화**: 아두이노 IDE는 코드에서 실제로 사용되는 부분만을 포함시키고, 사용되지 않는 라이브러리 함수는 제외시킵니다. 이로 인해 코드 크기를 줄이는 데 기여합니다.
2. **실행 속도 최적화**  실행 속도 최적화는 프로그램의 실행 시간을 줄여서 더 빠르게 동작하게 만드는 과정입니다. 이는 아두이노 보드가 더 빠르게 반응하고, 자주 반복되는 작업에서 성능을 최적화하는 데 중요합니다.  
주요 방법:  
 - **루프 최적화**: 자주 반복되는 루프에서 불필요한 계산을 최소화합니다. 예를 들어, 루프 외부에서 한 번만 계산해야 하는 값을 루프 안에서 반복적으로 계산하는 것을 피합니다.  
 - **조건문 최적화**: 조건문을 더 효율적으로 처리하여 실행 시간을 줄입니다. 예를 들어, 불필요한 조건문을 제거하거나, 더 빠른 방식으로 조건을 평가하도록 바꿀 수 있습니다.  
 - **자료형 최적화**: 데이터를 처리할 때 더 작은 자료형을 사용하여 메모리 사용을 최적화하고, 불필요한 타입 변환을 피할 수 있습니다. 예를 들어, `int` 대신 `byte`나 `char`를 사용하여 메모리를 절약할 수 있습니다.
  
최적화는 아두이노 프로젝트의 크기와 성능을 향상시킬 수 있는 중요한 과정입니다. **코드 크기 최적화**는 제한된 메모리 자원에서 더 많은 기능을 구현할 수 있게 하고, **속도 최적화**는 프로그램의 반응 시간을 단축시키고 성능을 향상시킵니다. 컴파일러는 이러한 최적화 작업을 자동으로 수행하지만, 개발자가 코드 작성 시 주의할 점들을 고려하면 더 효율적인 프로그램을 작성할 수 있습니다.  
  
#### 4. 컴파일 후 결과물 생성  
컴파일이 성공적으로 완료되면, 최종적으로 생성되는 파일은 .hex 파일입니다. 이 파일은 기계어 코드로, 아두이노 보드에서 실행될 준비가 된 파일입니다. 이 파일을 아두이노 IDE에서 업로드 버튼을 눌러 보드에 전송할 수 있습니다.  
  
#### 5. 컴파일 중 발생하는 오류  
컴파일 단계에서 코드에 오류가 있으면 컴파일이 실패하고, 에러 메시지가 아두이노 IDE의 하단에 출력됩니다. 컴파일 오류는 크게 두 가지로 나눌 수 있습니다.  
1. 구문 오류(Syntax Errors): 코드의 문법적인 오류로, 세미콜론 누락, 괄호 불일치 등에서 발생합니다.  
2. 링크 오류(Linking Errors): 함수나 변수가 선언되지 않았거나, 라이브러리가 제대로 포함되지 않은 경우 발생합니다.  
  
컴파일 단계는 아두이노 코드가 아두이노 보드에서 실행 가능한 바이너리 파일로 변환되는 중요한 과정입니다. 이 과정에서 코드가 구문 분석, 기계어 변환, 최적화 등의 단계로 처리되며, 최종적으로 .hex 파일을 생성합니다. 이 파일이 아두이노 보드에 업로드되어 실제로 실행되며, 하드웨어와 상호작용하게 됩니다.  
    
### 3) 라이브러리 기능  

#### (1) 라이브러리의 목적  

- 하드웨어 제어, 통신, 데이터 처리 등 다양한 기능을 손쉽게 사용할 수 있도록 해줍니다.  
- 예를 들어, 온도 센서를 읽거나, OLED 화면을 제어하거나, 와이파이 모듈을 사용하는 등의 복잡한 작업을 쉽게 구현할 수 있게 해줍니다.  

#### (2) 라이브러리 설치  

- **Arduino IDE**에서 라이브러리 매니저를 통해 손쉽게 설치할 수 있습니다. 라이브러리 매니저에서 필요한 라이브러리를 검색하고, 설치 버튼을 클릭하는 것만으로 설치가 완료됩니다.  
- 또한, **GitHub** 등에서 라이브러리를 다운로드해 수동으로 설치할 수도 있는데, 이 경우 라이브러리 폴더를 **Arduino IDE**의 `libraries` 폴더에 넣어야 합니다.  

#### (3) 라이브러리 사용 방법  

- 라이브러리를 사용하려면 먼저 코드의 상단에 `#include` 지시어를 사용해 해당 라이브러리를 불러옵니다.  
- 예를 들어, `LiquidCrystal` 라이브러리를 사용하려면 다음과 같이 코드 상단에 `#include`를 추가합니다.  
![Image](https://github.com/user-attachments/assets/84d70ea7-f612-4586-934d-61cbdbb56a98)  
위 사진과 같이 추가한 후, 라이브러리에서 제공하는 함수나 클래스를 사용하여 원하는 기능을 구현할 수 있습니다.  

#### (4) 라이브러리 종류  

**하드웨어 관련 라이브러리:** 센서, 디스플레이, 모터, 통신 모듈 등과 같은 하드웨어를 제어하는 데 필요한 라이브러리입니다.  
예: Wire (I2C 통신), SPI (SPI 통신), Servo (서보 모터 제어), DHT (온습도 센서)  

**소프트웨어 관련 라이브러리:** 문자열 처리, 수학 함수, 시간 제어 등을 위한 라이브러리입니다.  
예: Time (시간 제어), Adafruit_GFX (그래픽 디스플레이), SD (SD 카드 읽기/쓰기)  

**통신 관련 라이브러리:** Wi-Fi, 블루투스, 시리얼 통신 등을 다루는 라이브러리입니다.  
예: WiFi, Ethernet, SoftwareSerial  

#### (5) 라이브러리의 구조  

- 대부분의 Arduino 라이브러리는 `.h`(헤더 파일)와 `.cpp`(소스 파일)로 구성됩니다.  
- `.h` 파일은 라이브러리의 인터페이스를 정의하며, 클래스와 함수 선언이 포함됩니다.  
- `.cpp` 파일은 라이브러리의 실제 동작을 구현한 코드가 포함됩니다.  
- 이 외에도 일부 라이브러리는 예제 코드와 함께 제공되어 사용자가 쉽게 기능을 이해하고 활용할 수 있도록 돕습니다.  

#### (6) 라이브러리의 예시  

- `LiquidCrystal` 라이브러리는 LCD 화면을 제어하는 데 사용되며, 화면에 텍스트를 표시하거나 데이터를 출력하는 기능을 제공합니다.  
- `Servo` 라이브러리는 서보 모터를 제어하는 함수들을 제공합니다. 예를 들어, 서보 모터의 각도를 설정하거나, 서보를 특정 위치로 이동시킬 수 있습니다.  

#### (7) 라이브러리 관리  

- Arduino IDE에서는 설치된 라이브러리를 관리할 수 있는 **라이브러리 매니저 기능**이 있습니다. 이를 통해 추가, 삭제, 업데이트를 손쉽게 할 수 있습니다.  
- 라이브러리를 설치하려면: 스케치 -> 라이브러리 포함하기 -> 라이브러리 관리에서 라이브러리 검색 후 설치 가능합니다.  

#### (8) 자체 라이브러리 만들기  

- Arduino IDE에서 **자신만의 라이브러리**를 만들어 프로젝트를 더 깔끔하게 구성할 수 있습니다.
- 한번 라이브러리를 만들면 여러 프로젝트에서 재사용할 수 있기 때문에 코드 재사용성을 높일 수 있습니다.  
- 자체 라이브러리는 `#include`와 함께 사용하며, 클래스를 정의하고 필요한 기능을 메서드로 구현합니다.  

### 4) 보드 매니저(Board Manager)

Arduino IDE에서 보드 매니저(Board manager)는 아두이노 및 다양한 서드파티 보드를 설치하고 관리할 수 있게해주는 핵심 기능 중 하나이다.  
이 기능은 아두이노 환경을 확장 가능하고 유연하게 만들어주며, 다양한 하드웨어를 사용하는 프로젝트에 필수적인 역할을 한다.  
보드 매니저는 단순한 설정 도구가 아니라 하드웨어와 소프트웨어의 연결을 효율적으로 지원하는 아주 강력한 도구이다. 덕분에 아두이노 생태계는 더 많은 개발자와 메이커들에게 사랑받고 있으며 하드웨어에 대한 진입 장벽도 낮출 수 있게 되었다.
#### (1) 보드 매니저란?  
보드 매니저는 사용자가 여러 죵류의 마이크로 컨트롤러 보드를 아두이노에서 사용할 수 있도록 필요한 설정과 도구들을 자동으로 설치해주는 기능이다  
기본적으로는 Arduino UNO, Nano, Mega와 같은 전통적인 아두이노 보드들이 지원되지만 사용자가 직접 다른 보드를 추가로 설치하여 사용할 수 있다. 
각 보드는 사용하는 칩셋과 드라이버, 펌웨어 등이 다르기 때문에 이를 개발자가 수동으로 설정하기에는 매우 복잡하다. 하지만 보드 매니저를 사용하면 마우스 클릭 몇번으로 보드를 설치하고 쉽게 전환할 수 있다.  
#### (2) 기능 특징  
-자동 설치 및 구성 : 보드에 따라 필요한 컴파일러, 보드 설정 파일, 업로드 툴 등을 자동으로 설치해준다. 사용자는 복잡한 환경 설정 없이 사용할 수 있다.  
-멀티 보드 지원 : Arduino IDE 하나만으로 수십 종 이상의 보드를 설정하고 전환할 수 있다.  
-추가 보드 URL 등록 기능 : 공식 보드 외에도 오픈소스로 개발된 서드파티 보드를 사용할 수 있도록 외부 URL을 등록하여 확장 가능하다  
#### (3) 사용 방법  
##### 1) 기본 사용법  
1. Arduino IDE를 실행한다.
2. 상단 메뉴에서 Tools > Board > Board manager 를 클릭한다.  
3. 검색창에 원하는 보드를 입력한다.
4. 해당 보드를 선택하고 install 버튼을 클릭하면 자동으로 설치가 시작된다.  
5. 설치 완료 후 Tools > Board 에서 설치한 보드를 선택할 수 있다.
##### 2) 서드파티 보드 추가 방법  
1. 메뉴 File > Preferences로 이동한다. (단축키 Ctrl + , 로도 가능)  
2. Additional Board Manager URLs 항목에 보드 URL을 추가한다. (URL이 여러 개일 시 ,로 구분)  
3. 다시 Board Manager로 이동해 보드를 검색하고 설치한다.  
예시 : Iot 프로젝트에서 와이파이 기능이 필요한 경우 Arduino UNO로는 한계가 있다. 이때 ESP32 와 같은 보드를 사용하는 것이 유리한데 보드 매니저를 통해 ESP32를 손쉽게 설치하고 설정할 수 있다. 보드를 설치한 후에는 코드만 수정하면 바로 업로드 가능하며 와이파이 기능을 손쉽게 테스트할 수 있다.
또는 STM32 시리즈와 같은 고성능 보드를 설치하여 실시간 처리 프로젝트를 제작할 수 있다.
#### (4) 장단점  
##### 1) 장점
   보드 매니저는 기본적으로 아두이노 공식 보드 외에도 ESP32, STM32 등 수많은 서드파티 보드를 지원하여 단순한 학습용 플랫폼을 넘어 여러 곳에 활용될 수 있다.
   보드 매니저를 통해 보드를 설치하면 그에 필요한 컴파일러, 드라이버, 예제 코드까지 한번에 자동 설치되어 사용자인 복잡한 설정 없이 바로 개발을 시작할 수 있다.
   보드 매니저는 설치할 보드 패키지의 버전을 직접 선택할 수 있어 최신 버전에서 코드 문제가 생길 경우 이전 버전으로 롤백하여 문제를 해결할 수 있다.
   인터페이스가 초보자 친화적이어 복잡한 명령어 입력 없이도 설치와 설정이 가능하다.  
   설치된 보드를 최신 버전으로 자동 업데이트할 수 있는 기능을 제공하고 필요 없어진 보드는 클릭 한번으로 삭제할 수 있어 저장 공간을 효율적으로 확보할 수 있다.   
##### 2) 단점  
  서드파티 URL을 알지 못하면 원하는 보드를 설치하지 못하여 초보자 입장에서는 진입 장벽이 될 수 있다.  
  보드 매니저에 설치 가능한 보드가 수백 가지가 넘으므로 어떤 보드를 선택해야 할지 헷갈리고 이름이 비슷한 보드들이 많고 사용하려는 보드가 여러 모델을 지원하는 경우 혼란이 올 수 있다  
  여러 개의 보드를 설치했을 경우 특정 보드에서 사용하는 설정이 다른 보드와 충돌을 일으킬 수 있다.  
  보드 매니저에서 패키지를 최신으로 업데이트 하면 기존 프로젝트가 잘 작동하지 않거나 새 버전과 호환성 문제가 발생할 수 있다.

### 5) 예제코드 제공 기능 및 시리얼 모니터 기능

#### 예제코드 제공 기능
아두이노 IDE는 예제코드를 제공하는 기능이 있습니다. 
또한 아두이노 공식홈페이지에서도 확인할 수 있는데 이 기능을 통해 입문자들도 어렵지 않게 접할 수 있습니다. 

예제코드란 아두이노에서 공식적으로 제공하는 샘플코드로 센서, 모터, 통신 모듈 등 다양한 하드웨어를 어떻게 사용하는지 알려주는 코드 예시 입니다. 
예제코드를 여는 방법도 간편한데 아두이노 ide를 실행해서 메뉴에 있는 파일을 열면 예제가 나오고 카테고리 별로 예제가 나누어져 있어 본인에게 필요한 예제를 골라서 편리하게 사용할 수 있게 되어있습니다. 

카테고리에는 11개의 내장된 예제가 있는데 순서대로 소개하면 

01.basic은 아두이노의 가장 기본적인 기능에 대한 것이고(LED를 깜빡이는것, 디지털 핀의 상태를 시리얼 모니터에 출력, 아날로그 센서값을 시리얼로 출력 등) 

02.Digital은 디지털 입출력 관련 예제(버튼 입력을 읽어서 LED제어, 버튼 노이즈 제거, 상태변화 감지, 아날로그 센서로 소린 높이 조절 등)입니다. 

03.Analog는 아날로그 입력/출력에 관한 예제(아날로그 입력값 읽기, 아날로그 입력을 PMW출력으로 변환 등)이고 

04.Communication은 아두이노 간 또는 아두이노와 외부기기 간 통신에 관한 예제(시리얼명령으로 LED제어, PC로 받은 데이터를 그래프로 표시 등) 입니다. 

05.Control는 서브모터, 펄스 생성 등 제어관련 기능(순차적으로 연결된 핀 혹은 반복적인 일 처리, 조건문을 통한 제어 등), 

06.Sensor는 다양한 센서에 관한 것(초음파 센서를 통한 거리측정, 소리감지센서 등) 

07.Display는 LCD,OLED 같은 디스플레이 장치 사용(LED여러 개로 그래프 표현, 외부 디스플레이에 텍스트 출력 등), 

08.Strings는 문자열 처리 관련(문자열 덧셈, 비교, 대소문자 변환, 문자열 길이 측정 등), 

09.USB는 USB관련 예제(마우스 클릭 및 휠 동작 흉내 등), 

10.Starter Kit_BasicKit는 아두이노 공식 스타터 키트 전용 예제, 마지막 

11.ArduinolSP는 아두이노를 ISP(프로그래머)로 사용하는 예제입니다. 

마지막 예제는 개발자나 고급사용자가 많이 사용하며 일반 초보자 사용은 적습니다. 

이외에도 각종 함수, 센서에 관한 예제를 확인할 수 있습니다. 또한 예제를 수정해서 자신의 프로젝트에 맞게 변경할 수도 있습니다.

위 예제를 통해 초보자도 쉽게 이해 가능하며 주석도 잘 달려있어 이해하기 쉽다는 장점이 있습니다. 

또한 잘 테스트된 공식 예제들이라 컴파일 오류도 거의 발생하지 않습니다.


#### 시리얼 모니터 기능
시리얼 모니터란 아두이노 IDE 내에 있는 기능 중 하나로 아두이노와 시리얼 통신을 할 수 있는 기능입니다. 

아두이노 보드와 컴퓨터 간의 직렬 통신을 확인하고, 데이터를 주고받을 수 있는 텍스트 기반 콘솔 창입니다.

즉, 아두이노 보드에서 데이터를 출력하거나 사옹자가 보드로 문자를 입력할 수도 있습니다. 

시리얼 통신이란 1바이트의 데이터를 주고받는 직렬통신이라 보면 되는데 아두이노 같은 마이크로컨트롤러는 컴퓨터처럼 복잡한 통신장치가 없습니다. 

그래서 간단한 선 몇 개로만 통신을 해야되는데 여기서 시리얼통신이 적합한 역할을 하게됩니다. 

시리얼 모니터를 사용하는 이유는 여러가지가 있는데 우선 첫번째로는 코드를 확인하기 위한 목적(디버깅용)이 있습니다. 
아두이노의 변수값, 센서값, 조건문 결과 등을 출력해서 직접 확인할 수 있습니다. 이를 통해 문제나 오류가 발생했을 시 빠르고 편리하게 처리할 수 있다는 장점이 있습니다. 

두번째로는 센서값을 실시간으로 확인할 수 있는 것입니다. 
아두이노에는 상태를 보여줄 디스플레이가 없는데, 시리얼 모니터를 통해서 센서를 부착했을 때 데이터값이 얼마인 
지, 시스템 반응에 대한 수치와 같은 것을 시각화 하여 확인할 수 있습니다. 

세번째로 사용자 입력을 받을 수 있습니다. 
키보드로 시리얼 모니터 창에 문자/숫자를 입력해서 아두이노에게 명령을 줄 수 있습니다. 
테스트용 GUI가 없어도 직접 명령 전달 
이 가능하기에 빠른 테스트가 가능합니다.

네번째로는 보드와의 통신을 확인할 수 있다는 것입니다. 
예를 들어 단방향, 양방향 통신 중 제대로 통신이 되는지 궁금증이 들 때 시리얼 모니터를 통해 확인할 수 있습니다. 
이를통해 데이터가 정상 수신되는지 시각적으로 확인할 수 있고 통신오류가 생길 때 빠르게 문제를 잡을 수 있습니다.  

이외에도 프로그램 반응을 반복적으로 테스트 할 수 있다는 것, 기록과 복사 기능을 통해 실험데이터를 저장하고 비교분석 하는데 용이하다는 장점이 있습니다.
